<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>thinkphp thinkphp-queue 笔记  | 雨林之后</title>
<link rel="shortcut icon" href="https://yulinzhihou.github.io/favicon.ico?v=1660988316585">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yulinzhihou.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="thinkphp thinkphp-queue 笔记  | 雨林之后 - Atom Feed" href="https://yulinzhihou.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="前言
当前笔记中的内容针对的是 thinkphp-queue 的 v2.0 版本
传统的程序执行流程一般是 即时|同步|串行的，在某些场景下，会存在并发低，吞吐量低，响应时间长等问题。在大型系统中，一般会引入消息队列的组件，将流程中部分任务..." />
    <meta name="keywords" content="thinkphp,php" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yulinzhihou.github.io">
  <img class="avatar" src="https://yulinzhihou.github.io/images/avatar.png?v=1660988316585" alt="">
  </a>
  <h1 class="site-title">
    雨林之后
  </h1>
  <p class="site-description">
    IT互联网技术,学习折腾研究

  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/yulinzhihou" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              thinkphp thinkphp-queue 笔记 
            </h2>
            <div class="post-info">
              <span>
                2022-08-17
              </span>
              <span>
                33 min read
              </span>
              
                <a href="https://yulinzhihou.github.io/tag/0N84mDso99/" class="post-tag">
                  # thinkphp
                </a>
              
                <a href="https://yulinzhihou.github.io/tag/EITlFyhPi/" class="post-tag">
                  # php
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h3 id="前言">前言</h3>
<p>当前笔记中的内容针对的是 thinkphp-queue 的 v2.0 版本</p>
<p>传统的程序执行流程一般是 即时|同步|串行的，在某些场景下，会存在并发低，吞吐量低，响应时间长等问题。在大型系统中，一般会引入消息队列的组件，将流程中部分任务抽离出来放入消息队列，并由专门的消费者作针对性的处理，从而降低系统耦合度，提高系统性能和可用性。</p>
<p>一般来说，可以抽离的任务具有以下的特点：</p>
<ul>
<li>
<p><strong>允许延后|异步|并行处理</strong> （相对于传统的 <strong>即时|同步|串行</strong> 的执行方式）</p>
<ul>
<li>
<p><strong>允许延后</strong>：</p>
<p>抢购活动时，先快速缓冲有限的参与人数到消息队列，后续再排队处理实际的抢购业务；</p>
</li>
<li>
<p><strong>允许异步</strong>：</p>
<p>业务处理过程中的邮件，短信等通知</p>
</li>
<li>
<p><strong>允许并行</strong>：</p>
<p>用户支付成功之后，邮件通知，微信通知，短信通知可以由多个不同的消费者并行执行，通知到达的时间不要求先后顺序。</p>
</li>
</ul>
</li>
<li>
<p><strong>允许失败和重试</strong></p>
<ul>
<li>强一致性的业务放入核心流程处理</li>
<li>无一致性要求或最终一致即可的业务放入队列处理</li>
</ul>
</li>
</ul>
<p><strong><a href="https://github.com/top-think/think-queue/releases">thinkphp-queue</a></strong> 是thinkphp 官方提供的一个消息队列服务，它支持消息队列的一些基本特性：</p>
<ul>
<li>消息的<strong>发布</strong>，<strong>获取</strong>，<strong>执行</strong>，<strong>删除</strong>，<strong>重发</strong>，<strong>失败处理</strong>，<strong>延迟执行</strong>，<strong>超时控制</strong>等</li>
<li>队列的<strong>多队列</strong>， <strong>内存限制</strong> ，<strong>启动</strong>，<strong>停止</strong>，<strong>守护</strong>等</li>
<li>消息队列可<strong>降级为同步执行</strong></li>
</ul>
<p>thinkphp-queue 内置了 <strong>Redis</strong>，<strong>Database</strong>，<strong>Topthink</strong> ，<strong>Sync</strong>这四种驱动。本文主要介绍 thinkphp-queue 结合其内置的 redis 驱动的使用方式和基本原理。</p>
<p>注1：如无特殊说明，下文中的 ‘消息’ 和 ‘任务’两个词指代的是同一个概念，即队列中的一个成员。该成员对消息队列而言是其内部保存的消息； 对业务应用而言是一个待执行的任务。请根据语境区分。</p>
<p>注2：本文编写时(2019-01-30)使用的 thinkphp-queue 的版本号是 v2.0 。如有变更，请以官方最新版为准。</p>
<h3 id="一-代码示例">一 代码示例</h3>
<p>先通过一段代码，了解一下 thinkphp-queue 的基本使用流程。</p>
<blockquote>
<p>目标：</p>
<p>在业务控制器中推送一个新消息到一个名为 ‘helloJobQueue’ 的队列中，该消息中包含我们自定义的业务数据，然后，编写一个名为 Hello 的消费者类，并通过命令行去调用该消费者类获取这个消息，拿到定义的数据。</p>
</blockquote>
<h4 id="11-安装-thinkphp-queue">1.1 安装 thinkphp-queue</h4>
<pre><code class="language-bash">composer install topthink/think-queue
</code></pre>
<h4 id="12-搭建消息队列的存储环境">1.2 搭建消息队列的存储环境</h4>
<ul>
<li>
<p>使用 Redis [<strong>推荐</strong>]</p>
<pre><code>安装并启动 Redis 服务
</code></pre>
</li>
<li>
<p>使用数据库 [不推荐]</p>
<pre><code class="language-mysql">CREATE TABLE `prefix_jobs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `queue` varchar(255) NOT NULL,
  `payload` longtext NOT NULL,
  `attempts` tinyint(3) unsigned NOT NULL,
  `reserved` tinyint(3) unsigned NOT NULL,
  `reserved_at` int(10) unsigned DEFAULT NULL,
  `available_at` int(10) unsigned NOT NULL,
  `created_at` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
</li>
</ul>
<h4 id="13-配置消息队列的驱动">1.3 配置消息队列的驱动</h4>
<p>根据选择的存储方式，在 <code>\application\config\queue.php</code> 这个配置文件中，添加消息队列对应的驱动配置</p>
<pre><code class="language-php">   return [
       'connector'  =&gt; 'Redis',		// Redis 驱动
       'expire'     =&gt; 60,		// 任务的过期时间，默认为60秒; 若要禁用，则设置为 null 
       'default'    =&gt; 'default',		// 默认的队列名称
       'host'       =&gt; '127.0.0.1',	// redis 主机ip
       'port'       =&gt; 6379,		// redis 端口
       'password'   =&gt; '',		// redis 密码
       'select'     =&gt; 0,		// 使用哪一个 db，默认为 db0
       'timeout'    =&gt; 0,		// redis连接的超时时间
       'persistent' =&gt; false,		// 是否是长连接
     
   //    'connector' =&gt; 'Database',   // 数据库驱动
   //    'expire'    =&gt; 60,           // 任务的过期时间，默认为60秒; 若要禁用，则设置为 null
   //    'default'   =&gt; 'default',    // 默认的队列名称
   //    'table'     =&gt; 'jobs',       // 存储消息的表名，不带前缀
   //    'dsn'       =&gt; [],

   //    'connector'   =&gt; 'Topthink',	// ThinkPHP内部的队列通知服务平台 ，本文不作介绍
   //    'token'       =&gt; '',
   //    'project_id'  =&gt; '',
   //    'protocol'    =&gt; 'https',
   //    'host'        =&gt; 'qns.topthink.com',
   //    'port'        =&gt; 443,
   //    'api_version' =&gt; 1,
   //    'max_retries' =&gt; 3,
   //    'default'     =&gt; 'default',

   //    'connector'   =&gt; 'Sync',		// Sync 驱动，该驱动的实际作用是取消消息队列，还原为同步执行
   ];
</code></pre>
<p><strong>1.3.1 配置文件中的 expire 参数说明</strong></p>
<p>expire 参数指的是任务的过期时间, 单位为秒。 过期的任务，其准确的定义是</p>
<ol>
<li>任务的状态为执行中</li>
<li>任务的开始执行的时刻 + expire &gt; 当前时刻</li>
</ol>
<p>expire 不为<code>null</code> 时 ，thinkphp-queue 会在每次获取下一个任务之前检查并重发过期(执行超时)的任务。</p>
<p>expire 为<code>null</code> 时，thinkphp-queue 不会检查过期的任务，性能相对较高一点。但是需要注意：</p>
<ul>
<li>这些执行超时的任务会一直留在消息队列中，需要开发者另行处理(删除或者重发)！</li>
</ul>
<p><strong>对expire 参数理解或者使用不当时，很容易产生一些bug</strong>，后面会举例提到。</p>
<h4 id="14-消息的创建与推送">1.4 消息的创建与推送</h4>
<p>我们在业务控制器中创建一个新的消息，并推送到 <code>helloJobQueue</code> 队列</p>
<p>新增 <code>\application\index\controller\JobTest.php</code> 控制器，在该控制器中添加 <code>actionWithHelloJob</code> 方法</p>
<pre><code class="language-php">&lt;?php
/**
* 文件路径： \application\index\controller\JobTest.php
* 该控制器的业务代码中借助了thinkphp-queue 库，将一个消息推送到消息队列
*/
namespace app\index\controller;
  use think\Exception;

  use think\Queue;

  class JobTest {
  /**
   * 一个使用了队列的 action
   */
  public function actionWithHelloJob(){
      
      // 1.当前任务将由哪个类来负责处理。 
      //   当轮到该任务时，系统将生成一个该类的实例，并调用其 fire 方法
      $jobHandlerClassName  = 'app\index\job\Hello'; 
      
      // 2.当前任务归属的队列名称，如果为新队列，会自动创建
      $jobQueueName  	  = &quot;helloJobQueue&quot;; 
      
      // 3.当前任务所需的业务数据 . 不能为 resource 类型，其他类型最终将转化为json形式的字符串
      //   ( jobData 为对象时，存储其public属性的键值对 )
      $jobData       	  = [ 'ts' =&gt; time(), 'bizId' =&gt; uniqid() , 'a' =&gt; 1 ] ;
      
      // 4.将该任务推送到消息队列，等待对应的消费者去执行
      $isPushed = Queue::push( $jobHandlerClassName , $jobData , $jobQueueName );	
      
      // database 驱动时，返回值为 1|false  ;   redis 驱动时，返回值为 随机字符串|false
      if( $isPushed !== false ){  
          echo date('Y-m-d H:i:s') . &quot; a new Hello Job is Pushed to the MQ&quot;.&quot;&lt;br&gt;&quot;;
      }else{
          echo 'Oops, something went wrong.';
      }
  }
 }
</code></pre>
<p><strong>注意:</strong> 在这个例子当中，我们是手动指定的 <code>$jobHandlerClassName</code> ，更合理的做法是先定义好消息名称与消费者类名的映射关系，然后由某个可以获取该映射关系的类来推送这个消息。这样，生产者只需要知道消息的名称，而无需指定哪个消费者类来处理。</p>
<blockquote>
<p>除了 <code>Queue::push( $jobHandlerClassName , $jobData , $jobQueueName );	</code>这种方式之外，还可以直接传入 <code>Queue::push( $jobHandlerObject ,null , $jobQueueName );</code> 这时，需要在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>o</mi><mi>b</mi><mi>H</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mi>r</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">‘</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">‘</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">队</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">务</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">动</mi><mi mathvariant="normal">反</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">化</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">‘</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">‘</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">中</mi><mo separator="true">,</mo><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">提</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">挂</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">jobHandlerObject 中定义一个 `handle()` 方法，消息队列在执行到该任务时会自动反序列化该对象，并调用其 `handle()`方法。 该方式中, 数据需要提前挂载在 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord">‘</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">‘</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">队</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">动</span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">化</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">其</span><span class="mord">‘</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">‘</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">中</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">挂</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">在</span><span class="mord">‘</span></span></span></span>jobHandlerObject` 对象上。</p>
</blockquote>
<h4 id="15-消息的消费与删除">1.5 消息的消费与删除</h4>
<p>编写 Hello 消费者类，用于处理 <code>helloJobQueue</code> 队列中的任务</p>
<p>新增 <code>\application\index\job\Hello.php</code> 消费者类，并编写其 <code>fire()</code>  方法</p>
<pre><code class="language-php"> &lt;?php
  /**
   * 文件路径： \application\index\job\Hello.php
   * 这是一个消费者类，用于处理 helloJobQueue 队列中的任务
   */
  namespace app\index\job;

  use think\queue\Job;

  class Hello {
      
      /**
       * fire方法是消息队列默认调用的方法
       * @param Job            $job      当前的任务对象
       * @param array|mixed    $data     发布任务时自定义的数据
       */
      public function fire(Job $job,$data)
      {
          // 有些消息在到达消费者时,可能已经不再需要执行了
          $isJobStillNeedToBeDone = $this-&gt;checkDatabaseToSeeIfJobNeedToBeDone($data);
          if(!$isJobStillNeedToBeDone){
              $job-&gt;delete();
              return;
          }
        
          $isJobDone = $this-&gt;doHelloJob($data);
        
          if ($isJobDone) {
              // 如果任务执行成功， 记得删除任务
              $job-&gt;delete();
              print(&quot;&lt;info&gt;Hello Job has been done and deleted&quot;.&quot;&lt;/info&gt;\n&quot;);
          }else{
              if ($job-&gt;attempts() &gt; 3) {
                  //通过这个方法可以检查这个任务已经重试了几次了
                  print(&quot;&lt;warn&gt;Hello Job has been retried more than 3 times!&quot;.&quot;&lt;/warn&gt;\n&quot;);
                  
  				        $job-&gt;delete();
                  
                  // 也可以重新发布这个任务
                  //print(&quot;&lt;info&gt;Hello Job will be availabe again after 2s.&quot;.&quot;&lt;/info&gt;\n&quot;);
                  //$job-&gt;release(2); //$delay为延迟时间，表示该任务延迟2秒后再执行
              }
          }
      }
      
      /**
       * 有些消息在到达消费者时,可能已经不再需要执行了
       * @param array|mixed    $data     发布任务时自定义的数据
       * @return boolean                 任务执行的结果
       */
      private function checkDatabaseToSeeIfJobNeedToBeDone($data){
          return true;
      }

      /**
       * 根据消息中的数据进行实际的业务处理...
       */
      private function doHelloJob($data) 
      {
          print(&quot;&lt;info&gt;Hello Job Started. job Data is: &quot;.var_export($data,true).&quot;&lt;/info&gt; \n&quot;);
          print(&quot;&lt;info&gt;Hello Job is Fired at &quot; . date('Y-m-d H:i:s') .&quot;&lt;/info&gt; \n&quot;);
          print(&quot;&lt;info&gt;Hello Job is Done!&quot;.&quot;&lt;/info&gt; \n&quot;);
          
          return true;
      }
  }
</code></pre>
<p>至此，所有的代码都已准备完毕，在运行消息队列之前，我们先看一下现在的目录结构：</p>
<figure data-type="image" tabindex="1"><img src="%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png" alt="目录结构-代码示例" loading="lazy"></figure>
<h4 id="16-发布任务">1.6 发布任务</h4>
<p>在浏览器中访问  http://your.project.domain/index/job_test/actionWithHelloJob ,可以看到消息推送成功。</p>
<figure data-type="image" tabindex="2"><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%BB%93%E6%9E%9C.png" alt="浏览器提示消息推送结果" loading="lazy"></figure>
<h4 id="17-处理任务">1.7 处理任务</h4>
<p>切换当前终端窗口的目录到项目根目录下，执行</p>
<pre><code class="language-bash">php think queue:work --queue helloJobQueue
</code></pre>
<p>可以看到执行的结果类似如下:</p>
<figure data-type="image" tabindex="3"><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="命令行执行结果" loading="lazy"></figure>
<p>至此，我们成功地经历了一个消息的 创建 -&gt; 推送 -&gt; 消费 -&gt; 删除  的基本流程</p>
<p>下文，将介绍 thinkphp-queue 的详细使用方法。如配置介绍，基本原理，各种特殊情况的处理等</p>
<h3 id="二-详细介绍">二 详细介绍</h3>
<h4 id="21-命令模式">2.1 命令模式</h4>
<ul>
<li>
<p><strong>queue:subscribe 命令</strong> [官方未提供示例, 略过]</p>
</li>
<li>
<p><strong>queue:work 命令</strong></p>
<p>work 命令： 该命令将启动一个 work 进程来处理消息队列。</p>
<pre><code class="language-bash">php think queue:work --queue helloJobQueue
</code></pre>
</li>
<li>
<p><strong>queue:listen 命令</strong></p>
<p>listen 命令： 该命令将会启动一个 listen 进程 ，然后由 listen 进程通过 <code>proc_open(‘php think queue:work  --queue=&quot;%s&quot; --delay=%s --memory=%s --sleep=%s --tries=%s’)</code> 的方式来周期性地创建一次性的 work 进程来消费消息队列, 并且限制该 work 进程的执行时间, 同时通过管道来监听 work 进程的输出，。</p>
<pre><code class="language-bash">php think queue:listen --queue helloJobQueue
</code></pre>
</li>
</ul>
<h4 id="22-命令行参数">2.2 命令行参数</h4>
<ul>
<li>
<p>Work 模式</p>
<pre><code class="language-bash">php think queue:work \
--daemon            //是否循环执行，如果不加该参数，则该命令处理完下一个消息就退出
--queue  helloJobQueue  //要处理的队列的名称
--delay  0 \        //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0
--force  \          //系统处于维护状态时是否仍然处理任务，并未找到相关说明
--memory 128 \      //该进程允许使用的内存上限，以 M 为单位
--sleep  3 \        //如果队列中无任务，则sleep多少秒后重新检查(work+daemon模式)或者退出(listen或非daemon模式)
--tries  2          //如果任务已经超过尝试次数上限，则触发‘任务尝试次数超限’事件，默认为0
</code></pre>
</li>
<li>
<p>Listen 模式</p>
<pre><code class="language-bash">php think queue:listen \
--queue  helloJobQueue \   //监听的队列的名称
--delay  0 \         //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0
--memory 128 \       //该进程允许使用的内存上限，以 M 为单位
--sleep  3 \         //如果队列中无任务，则多长时间后重新检查
--tries  0 \         //如果任务已经超过重发次数上限，则进入失败处理逻辑，默认为0
--timeout 60         // work 进程允许执行的最长时间，以秒为单位
</code></pre>
<p>可以看到 listen 模式下，不包含 <code>--deamon</code> 参数，原因下面会说明</p>
</li>
</ul>
<h4 id="23-work-模式和-listen-模式的区别">2.3 work 模式和 listen 模式的区别</h4>
<p>两者都可以用于处理消息队列中的任务</p>
<p>区别在于:</p>
<ul>
<li>
<p><strong>2.3.1 执行原理不同</strong></p>
<ul>
<li>
<p>work 命令是<strong>单进程</strong>的处理模式。</p>
<p>按照是否设置了 <code>--daemon</code> 参数，work命令又可分为单次执行和循环执行两种模式。</p>
<ul>
<li>单次执行：不添加 <code>--daemon</code>参数，该模式下,work进程在处理完下一个消息后直接结束当前进程。当队列为空时，会sleep一段时间然后退出。</li>
<li>循环执行：添加了 <code>--daemon</code>参数，该模式下,work进程会循环地处理队列中的消息，直到内存超出参数配置才结束进程。当队列为空时，会在每次循环中sleep一段时间。</li>
</ul>
</li>
<li>
<p>listen 命令是 <strong>双进程 + 管道</strong> 的处理模式。</p>
<p>listen命令所在的进程会循环地创建 <strong>单次执行模式的 work 进程</strong>，每次创建的 work 进程只消费一个消息就会结束, 然后 listen 进程再创建一个新的 work 进程，</p>
<ul>
<li>listen 进程会定时检查当前的 work 进程执行时间是否超过了 --timeout 参数的值, 如果已超时, 则 listen 进程会 kill 掉 work 进程, 然后抛出异常</li>
<li>listen 进程会通过管道来监听当前的 work 进程的输出, 当 work 进程有输出时, listen 进程会将输出写入到 stdout / stderr</li>
<li>listen 进程会定时通过 <code>proc_get_status()</code> 来监控当前的 work 进程是否仍在运行, work 进程消费完一个任务之后, work 进程就结束了，其状态会变成 terminated, 此时 listen 进程就会重新创建一个新的 work 进程并对其计时, 新的 work 进程开始消费下一个任务</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>2.3.2 结束时机不同</strong></p>
<ul>
<li>work 命令的结束时机在上面的执行原理部分已叙述，此处不再重复</li>
<li>listen 命令中，listen 进程和 work 进程会在以下情况下结束：
<ul>
<li>listen 进程会定时检查当前的 work 进程的执行时间是否超过了 --timeout 参数的值，如果已超时, 此时 listen 进程会先 kill 掉当前的 work 进程, 然后抛出一个 <code>ProcessTimeoutException</code> 异常并结束 listen 进程</li>
<li>listen 进程会定时检查自身使用的内存是否超过了 <code>--memory</code> 参数的值，如果已超过, 此时 listen 进程会直接 die 掉, work 进程也会自动结束.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>2.3.3 性能不同</strong></p>
<ul>
<li>
<p>work 命令是在脚本内部做循环，框架脚本在命令执行的初期就已加载完毕；</p>
</li>
<li>
<p>而listen模式则是处理完一个任务之后新开一个work进程，此时会重新加载框架脚本。</p>
<p>因此： <strong>work 模式的性能会比listen模式高</strong>。</p>
<p>注意：当代码有更新时，work 模式下需要手动去执行 <code>php think queue:restart</code> 命令重启队列来使改动生效；而listen 模式会自动生效,无需其他操作。</p>
</li>
</ul>
</li>
<li>
<p><strong>2.3.4 超时控制能力</strong></p>
<ul>
<li>
<p>work 模式本质上既不能控制进程自身的运行时间，也无法限制执行中的任务的执行时间。</p>
<p>举例来说，假如你在某次上线之后，在上文中的  <code>\application\index\job\Hello.php</code> 消费者的<code>fire</code>方法中添加了一段死循环 ：</p>
<pre><code class="language-php">public function fire(){
   while(true){ //死循环
       $consoleOutPut-&gt;writeln(&quot;&lt;info&gt;I am looping forever inside a job.&lt;/info&gt; \n&quot;);
       sleep(1);
   }
}  
</code></pre>
<p>那么这个循环将永远不能停止，直到任务所在的进程超过内存限制或者由管理员手动结束。这个过程不会有任何的告警。更严重的是，如果你配置了expire ，那么这个死循环的任务可能会污染到同样处理 <code>helloJobQueue</code> 队列的其他work进程，最后好几个work进程将被卡死在这段死循环中。详情后文会说明。</p>
<p><strong>work 模式下的超时控制能力，实际上应该理解为 多个work 进程配合下的过期任务重发能力。</strong></p>
</li>
<li>
<p>而 listen 命令可以限制 listen 进程创建的 work 进程的最大执行时间。</p>
<p>listen 命令可通过 <code>--timeout</code> 参数限制 work 进程允许运行的最长时间，超过该时间限制后, work 进程会被强制 kill 掉, listen 进程本身也会抛出异常并结束；</p>
</li>
<li>
<p>这里有必要补充一下 expire 和 timeout 之间的区别：</p>
<ul>
<li>
<p>expire 在配置文件中设置，timeout 在 listen命令 的命令行参数中设置，而且，expire 和 timeout 是两个不同层次上的概念：</p>
</li>
<li>
<p>expire 是指任务的过期时间。这个时间是全局的，影响到所有的work进程。(不管是独立的work命令还是 listen 模式下创建的的 work 进程) 。expire 针对的对象是 <strong>任务</strong>。</p>
</li>
<li>
<p>timeout 是指 work 进程的超时时间。这个时间只对当前执行的 listen 命令有效。timeout 针对的对象是 <strong>work 进程</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>2.3.5 使用场景不同</strong></p>
<p>根据上面的介绍，可以看到，</p>
<p>work 命令的适用场景是：</p>
<ul>
<li>任务数量较多</li>
<li>性能要求较高</li>
<li>任务的执行时间较短</li>
<li>消费者类中不存在死循环，sleep() ，exit() ,die() 等容易导致bug的逻辑</li>
</ul>
<p>listen命令的适用场景是：</p>
<ul>
<li>任务数量较少</li>
<li>任务的执行时间较长(如生成大型的excel报表等)，</li>
<li>任务的执行时间需要有严格限制</li>
</ul>
</li>
</ul>
<h4 id="24-消息队列的开始停止与重启">2.4 消息队列的开始，停止与重启</h4>
<ul>
<li>
<p>开始一个消息队列：</p>
<pre><code class="language-bash">php think queue:work
</code></pre>
</li>
<li>
<p>停止所有的消息队列：</p>
<pre><code class="language-bash">php think queue:restart
</code></pre>
</li>
<li>
<p>重启所有的消息队列：</p>
<pre><code class="language-bash">php think queue:restart 
php think queue:work 
</code></pre>
</li>
</ul>
<h4 id="25-多模块多任务的处理">2.5 多模块，多任务的处理</h4>
<ul>
<li>
<p>多模块</p>
<blockquote>
<p>单模块项目推荐使用 <code>app\job</code> 作为任务类的命名空间</p>
<p>多模块项目可用使用 <code>app\module\job</code> 作为任务类的命名空间 也可以放在任意可以自动加载到的地方</p>
</blockquote>
</li>
<li>
<p>多任务</p>
<blockquote>
<p>如果一个任务类里有多个小任务的话，在发布任务时，需要用 <code>任务的类名@方法名</code> 如 <code>app\lib\job\Job2@task1</code>、<code>app\lib\job\Job2@task2</code></p>
<p>注意：命令行中的 --queue  参数不支持@解析</p>
</blockquote>
<p>多任务例子:</p>
<ul>
<li>在 <code>\application\index\controller\JobTest.php</code> 控制器中，添加 <code>actionWithMultiTask()</code>方法：</li>
</ul>
<pre><code class="language-php">public function actionWithMultiTask(){
    	
  $taskType = $_GET['taskType'];
    switch ($whichTask) {
       case 'taskA':
           $jobHandlerClassName  = 'application\index\job\MultiTask@taskA';
           $jobDataArr = ['a'	=&gt; '1'];
           $jobQueueName = &quot;multiTaskJobQueue&quot;;	
           break;
       case 'taskB':
           $jobHandlerClassName  = 'application\index\job\MultiTask@taskB';
           $jobDataArr = ['b'	=&gt; '2'];
           $jobQueueName = &quot;multiTaskJobQueue&quot;;		
           break;
        default:
           break;
   }
  
  $isPushed = Queue::push($jobHandlerClassName, $jobDataArr, $jobQueueName);
  if ($isPushed !== false) {
    echo(&quot;the $taskType of MultiTask Job has been Pushed to &quot;.$jobQueueName .&quot;&lt;br&gt;&quot;);
  }else{
    throw new Exception(&quot;push a new $taskType of MultiTask Job Failed!&quot;);
  }
}
</code></pre>
<ul>
<li>新增 <code>\application\index\job\MultiTask.php</code> 消费者类，并编写其 <code>taskA()</code>  和 <code>taskB()</code>方法</li>
</ul>
<pre><code class="language-php">&lt;?php
/**
 * 文件路径： \application\index\job\MultiTask.php
 * 这是一个消费者类，用于处理 multiTaskJobQueue 队列中的任务
 */
namespace app\index\job;

use think\queue\Job;

class MultiTask {
 
    public function taskA(Job $job,$data){
        
        $isJobDone = $this-&gt;_doTaskA($data);

        if ($isJobDone) {
            $job-&gt;delete();
            print(&quot;Info: TaskA of Job MultiTask has been done and deleted&quot;.&quot;\n&quot;);
        }else{
            if ($job-&gt;attempts() &gt; 3) {
                $job-&gt;delete(); 	
            }
        }
    }
  
    public function taskB(Job $job,$data){
        
        $isJobDone = $this-&gt;_doTaskA($data);

        if ($isJobDone) {
            $job-&gt;delete();
            print(&quot;Info: TaskB of Job MultiTask has been done and deleted&quot;.&quot;\n&quot;);
        }else{
            if ($job-&gt;attempts() &gt; 2) {
                $job-&gt;release(); 	
            }
        }
    }

    private function _doTaskA($data) {
        print(&quot;Info: doing TaskA of Job MultiTask &quot;.&quot;\n&quot;);
        return true;
    }
  
    private function _doTaskB($data) {
        print(&quot;Info: doing TaskB of Job MultiTask &quot;.&quot;\n&quot;);
        return true;
    }
</code></pre>
</li>
</ul>
<h4 id="26-消息的延迟执行与定时执行">2.6 消息的延迟执行与定时执行</h4>
<p>延迟执行，相对于即时执行，是用来限制某个任务的最早可执行时刻。在到达该时刻之前，该任务会被跳过。</p>
<p>可以利用该功能实现<strong>定时任务</strong>。</p>
<p>使用方式：</p>
<ul>
<li>在生产者业务代码中：</li>
</ul>
<pre><code class="language-php">// 即时执行
$isPushed = Queue::push($jobHandlerClassName, $jobDataArr, $jobQueueName);

// 延迟 2 秒执行
$isPushed = Queue::later( 2, $jobHandlerClassName, $jobDataArr, $jobQueueName);

// 延迟到 2017-02-18 01:01:01 时刻执行
$time2wait = strtotime('2017-02-18 01:01:01') - strtotime('now');	
$isPushed = Queue::later($time2wait,$jobHandlerClassName, $jobDataArr, $jobQueueName);
</code></pre>
<ul>
<li>在消费者类中：</li>
</ul>
<pre><code class="language-php">// 重发，即时执行
$job-&gt;release();

// 重发，延迟 2 秒执行
$job-&gt;release(2);

// 延迟到 2017-02-18 01:01:01 时刻执行
$time2wait = strtotime('2017-02-18 01:01:01') - strtotime('now');
$job-&gt;release($time2wait);
</code></pre>
<ul>
<li>在命令行中：</li>
</ul>
<pre><code class="language-bash">//如果消费者类的fire()方法抛出了异常且任务未被删除时，将自动重发该任务，重发时，会设置其下次执行前延迟多少秒,默认为0
php think queue:work --delay 3  
</code></pre>
<h4 id="27-消息的重发">2.7 消息的重发</h4>
<p>thinkphp-queue 中，消息的重发时机有3种：</p>
<ul>
<li>2.7.1 在消费者类中手动重发：</li>
</ul>
<pre><code class="language-php">if( $isJobDone === false){
    $job-&gt;release();
}
</code></pre>
<ul>
<li>2.7.2 work进程自动重发，需同时满足以下两个条件
<ul>
<li>消费者类的 fire() 方法抛出了异常</li>
<li>任务未被删除</li>
</ul>
</li>
<li>2.7.3 当配置了 expire 不为 <code>null</code> 时，work 进程内部每次查询可用任务之前，会先自动重发已过期的任务。</li>
</ul>
<blockquote>
<p>补充：</p>
<p>在database 模式下，2.7.1 和 2.7.2 中的重发逻辑是先删除原来的任务，然后插入一个新的任务。2.7.3 中的重发时机是直接更新原任务。</p>
<p>而在redis 模式下，3种重发都是先删除再插入。</p>
<p>不管是哪种重发方式，重发之后，任务的已尝试次数会在原来的基础上 +1 。</p>
</blockquote>
<p>此外，消费者类中需要注意，如果 <code>fire()</code> 方法中可能抛出异常，那么</p>
<ul>
<li>如果不需要自动重发的话， 请在抛出异常之前将任务删除 <code>$job-&gt;delete()</code> ，否则会被框架自动重发。</li>
<li>如果需要自动重发的话，请直接抛出异常，不要在 <code>fire()</code> 方法中又手动使用 <code>$job-&gt;release()</code> , 这样会导致该任务被重发两次，产生两个一样的新任务。</li>
</ul>
<h4 id="28-任务的失败回调及告警">2.8 任务的失败回调及告警</h4>
<p>当同时满足以下条件时，将触发任务失败回调：</p>
<ul>
<li>命令行的 <code>--tries</code> 参数的值大于0</li>
<li>任务的已尝试次数大于 命令行的 <code>--tries</code> 参数</li>
<li>开发者添加了 <code>queue_failed</code> 事件标签及其对应的回调代码</li>
<li>消费者类中定义了 <code>failed()</code> 方法，用于接收任务失败的通知</li>
</ul>
<p>注意， <code>queue_failed</code> 标签需要在安装了 <code>thinkphp-queue </code> 之后 <strong>手动</strong> 去 <code>\application\tags.php</code> 文件中添加。</p>
<p>首先，我们添加 <code>queue_failed</code> 事件标签,  及其对应的回调方法</p>
<pre><code class="language-php">// 文件路径： \application\tags.php
// 应用行为扩展定义文件
return [
    // 应用初始化
    'app_init'     =&gt; [],
    // 应用开始
    'app_begin'    =&gt; [],
    // 模块初始化
    'module_init'  =&gt; [],
    // 操作开始执行
    'action_begin' =&gt; [],
    // 视图内容过滤
    'view_filter'  =&gt; [],
    // 日志写入
    'log_write'    =&gt; [],
    // 应用结束
    'app_end'      =&gt; [],

    // 任务失败统一回调,有四种定义方式
    'queue_failed'=&gt; [
      
         // 数组形式，[ 'ClassName' , 'methodName']
        ['application\\behavior\\MyQueueFailedLogger', 'logAllFailedQueues']
         
         // 字符串(静态方法)，'StaicClassName::methodName'
         // 'MyQueueFailedLogger::logAllFailedQueues'   
      
         // 字符串(对象方法)，'ClassName'，此时需在对应的ClassName类中添加一个名为 queueFailed 的方法
         // 'application\\behavior\\MyQueueFailedLogger'
         
         // 闭包形式
         /*
         function( &amp;$jobObject , $extra){
             // var_dump($jobObject);
             return true;
         }
         */
    ]
];
</code></pre>
<p>这里，我们选择数组形式的回调方式，新增 <code>\application\behavior\MyQueueFailedLogger</code> 类，添加一个 <code>logAllFailedQueues()</code> 方法</p>
<pre><code class="language-php">&lt;?php
/**
 * 文件路径: \application\behavior\MyQueueFailedLogger.php
 * 这是一个行为类，用于处理所有的消息队列中的任务失败回调
 */

namespace app\behavior;


class MyQueueFailedLogger {
       
    const should_run_hook_callback = true;
  
    /**
     * @param $jobObject   \think\queue\Job   //任务对象，保存了该任务的执行情况和业务数据
     * @return bool     true                  //是否需要删除任务并触发其failed() 方法
     */
    public function logAllFailedQueues(&amp;$jobObject){
        
        $failedJobLog = [
            'jobHandlerClassName'   =&gt; $jobObject-&gt;getName(), // 'application\index\job\Hello'
            'queueName' =&gt; $jobObject-&gt;getQueue(),			   // 'helloJobQueue'	 
            'jobData'   =&gt; $jobObject-&gt;getRawBody()['data'],  // '{'a': 1 }'
            'attempts'  =&gt; $jobObject-&gt;attempts(),            // 3
        ];
        var_export(json_encode($failedJobLog,true));
        
           // $jobObject-&gt;release();     //重发任务
          //$jobObject-&gt;delete();         //删除任务
          //$jobObject-&gt;failed();	  //通知消费者类任务执行失败
        
        return self::should_run_hook_callback;         
    }
}
</code></pre>
<p>需要注意该回调方法的返回值：</p>
<ul>
<li>返回 true  时，系统会自动删除该任务，并且自动调用消费者类中的 <code>failed()</code> 方法</li>
<li>返回 false 时，系统不会自动删除该任务，也不会自动调用消费者类中的 <code>failed()</code> 方法，需要开发者另行处理失败任务的删除和通知。</li>
</ul>
<p>最后，在消费者类中，添加 <code>failed()</code> 方法</p>
<pre><code class="language-php">/**
 * 文件路径： \application\index\job\HelloJob.php
 */

/**
 * 该方法用于接收任务执行失败的通知，你可以发送邮件给相应的负责人员
 * @param $jobData  string|array|...      //发布任务时传递的 jobData 数据
 */
public function failed($jobData){
    send_mail_to_somebody() ; 
    
    print(&quot;Warning: Job failed after max retries. job data is :&quot;.var_export($data,true).&quot;\n&quot;; 
}
</code></pre>
<p>这样，就可以做到任务失败的<strong>记录</strong>与<strong>告警</strong></p>
<h4 id="29-处理过期的任务">2.9 处理过期的任务</h4>
<p>过期这个概念用文字比较难描述清楚，建议先看一下 <strong>深入理解</strong> 中 <strong>3.4 消息处理的详细流程图</strong></p>
<h3 id="三-深入理解">三 深入理解</h3>
<h4 id="31-thinkphp-queue-中消息与队列的保存方式">3.1 thinkphp-queue 中消息与队列的保存方式</h4>
<ul>
<li>
<p>Redis</p>
<p>在 Redis 中，每一个 队列 都三个key 与之对应 ，以 helloJobQueue 队列举例，其在redis 中的保存方式为：</p>
<table>
<thead>
<tr>
<th>key名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>queues:helloJobQueue</td>
<td>List ， 列表</td>
<td>待执行的任务列表</td>
</tr>
<tr>
<td>queues:helloJobQueue:delayed</td>
<td>Sorted Set，有序集合</td>
<td>延迟执行和定时执行的任务集合</td>
</tr>
<tr>
<td>queues:helloJobQueue:reserved</td>
<td>Sorted Set，有序集合</td>
<td>执行中的任务集合</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用的<code>:</code>分隔符, 只是用来表示相关key的关联性。本身没有特殊含义。使用分隔符是一种常见的组织key的方式。</p>
</blockquote>
<p>其中，在<code>queues:helloJobQueue</code> 列表中，每个元素的形式如下：</p>
<figure data-type="image" tabindex="4"><img src="redis%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97-queue.png" alt="redis中的队列-queue" loading="lazy"></figure>
<p>在 <code>queues:helloJobQueue:delayed</code> 和 <code>queues:helloJobQueue:delayed</code> 有序集合中，每个元素的形式如下：</p>
<figure data-type="image" tabindex="5"><img src="redis%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97-queue-reserved.png" alt="redis中的队列-queue-reserved" loading="lazy"></figure>
<p>可以看到，在有序集合中，每个元素代表一个任务，该元素的 Score 为该任务的入队时间戳，任务的 value 为json 格式，保存了任务的执行情况和业务数据。将value decode 为数组后形式如下：</p>
<pre><code class="language-php">[
  'job'  =&gt; 'application\\index\\job\\Hello' ,  // jobHandlerClassName，消费者类的类名 
  'data' =&gt; [					  // 生产者传入的业务数据
     'time' =&gt; '2017-02-18 16:20:10',
     'data' =&gt; 'I have 648 apples'
  ],
  'id'   =&gt; '77IasdasadIasdadadadKL8t',	// 一个随机的32位字符串
  'attempts' =&gt; 2				// 任务的已尝试次数
]
</code></pre>
<p>redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移，详情可见 3.5</p>
</li>
<li>
<p>Database</p>
<p>在 Database 中，每个任务对应到表中的一行，queue 字段用来区分不同的队列。</p>
<p>表的字段结构如下:</p>
<figure data-type="image" tabindex="6"><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E.png" alt="数据库字段说明" loading="lazy"></figure>
<p>其中，payLoad 字段保存了消息的执行者和业务数据，payLoad 字段采用 json 格式的字符串来保存消息，将其 decode 为数组后形式如下：</p>
<pre><code class="language-php">[
 'job'   =&gt; 'application\\index\\job\\Hello', // jobHandlerClassName，消费者类的类名 
 'data'  =&gt; string|array|integer|object       // 生产者传入的业务数据
]
</code></pre>
</li>
</ul>
<h4 id="32-thinkphp-queue-的目录结构和类关系图">3.2 thinkphp-queue 的目录结构和类关系图</h4>
<figure data-type="image" tabindex="7"><img src="thinkphp-queue%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="thinkphp-queue的文件目录" loading="lazy"></figure>
<p>这些类构成了消息队列中的几个角色：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令行</td>
<td>Command + Worker</td>
<td>负责解析命令行参数，控制队列的启动，重启</td>
</tr>
<tr>
<td>驱动</td>
<td>Queue + Connector</td>
<td>负责队列的创建，以及消息的入队，出队等操作</td>
</tr>
<tr>
<td>任务</td>
<td>Job</td>
<td>用于将消息转化为一个任务对象，供消费者使用</td>
</tr>
<tr>
<td>生产者</td>
<td>业务代码</td>
<td>负责消息的创建与发布</td>
</tr>
<tr>
<td>消费者</td>
<td>业务代码</td>
<td>负责任务的接收与执行</td>
</tr>
</tbody>
</table>
<p>各个类之间的关系图如下：</p>
<figure data-type="image" tabindex="8"><img src="https://github.com/coolseven/notes/blob/master/thinkphp-queue/thinkphp-queue%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.svg" alt="thinkphp-queue类关系图" loading="lazy"></figure>
<h4 id="33-deamon模式的执行流程">3.3 Deamon模式的执行流程</h4>
<figure data-type="image" tabindex="9"><img src="https://github.com/coolseven/notes/blob/master/thinkphp-queue/Daemon%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9Edaemon%E6%A8%A1%E5%BC%8F%E7%8A%B6%E6%80%81%E5%9B%BE.svg" alt="Daemon模式与非daemon模式状态图" loading="lazy"></figure>
<h4 id="34-database模式下消息处理的详细流程">3.4 Database模式下消息处理的详细流程</h4>
<p>下图中，展示了database 模式下消息处理的详细流程，redis 驱动下大体类似</p>
<figure data-type="image" tabindex="10"><img src="https://github.com/coolseven/notes/blob/master/thinkphp-queue/%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.svg" alt="Database模式下消息获取和执行的具体流程" loading="lazy"></figure>
<h4 id="35-redis-驱动下的任务重发细节">3.5 redis 驱动下的任务重发细节</h4>
<p>在redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移。</p>
<p>在3.4 Database模式下消息处理的消息流程中，我们知道，如果配置的expire 不是null ，那么 thinkphp-queue的work进程每次在获取下一个可执行任务之前，会先尝试重发所有过期的任务。而在redis驱动下，这个步骤则做了更多的事情，详情如下：</p>
<ol>
<li>从 <code>queue:xxx:delayed</code> 的key中查询出有哪些任务在当前时刻已经可以开始执行，然后将这些任务转移到 <code>queue:xxx</code> 的key的尾部。</li>
<li>从 <code>queue:xxx:reserved</code> 的key中查询出有哪些任务在当前时刻已经过期，然后将这些任务转移到 <code>queue:xxx</code>的key的尾部。</li>
<li>尝试从 <code>queue:xxx</code> 的key的头部取出一个任务，如果取出成功，那么，将这个任务转移到 <code>queue:xxx:reserved</code> 的key 的头部，同时将这个任务实例化成任务对象，交给消费者去执行。</li>
</ol>
<p>用图来表示这个步骤的具体过程如下：</p>
<p>redis队列中的过期任务重发步骤--执行前：</p>
<figure data-type="image" tabindex="11"><img src="redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-1.png" alt="redis队列中的过期任务重发步骤-执行前" loading="lazy"></figure>
<p>redis队列中的过期任务重发步骤--执行后：</p>
<figure data-type="image" tabindex="12"><img src="redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-2.png" alt="redis队列中的过期任务重发步骤--执行后" loading="lazy"></figure>
<h4 id="36-thinkphp-queue的性能">3.6 thinkphp-queue的性能</h4>
<ul>
<li>
<p>测试环境 :</p>
<p>虚拟机 Ubuntu 16.04 ， PHP 7.1 ，TP5，Redis 3.2 ， 双核 I5 6400，3G 内存</p>
</li>
<li>
<p>测试方式 :</p>
<p>使用 Redis 驱动，在一个控制器中循环推送 40000 条消息到消息队列；</p>
<p>使用<code>php think queue:work --daemon</code>去消费这些消息，计算推送和消费各自所耗的时间。</p>
</li>
<li>
<p>测试结果 :</p>
<p>在最简单的逻辑下，平均每秒中可推送8000个消息，平均每秒可消费200个消息。</p>
</li>
</ul>
<p><strong>注意：<strong>由于在测试时，Host 机本身的cpu和内存长期100%，并且虚拟机中的各项服务并未专门调优，因此该测试结果</strong>并不具备参考性</strong>。</p>
<h4 id="37-thinkphp-queue-的注意事项">3.7 thinkphp-queue 的注意事项</h4>
<ul>
<li>
<p><strong>3.7.1</strong> 使用建议</p>
<ul>
<li><strong>任务完成后, 使用 <code>$job-&gt;delete()</code> 删除任务</strong></li>
<li>在消费者类的 <code>fire()</code> 方法中，使用 <code>$job-&gt;attempt()</code>  检查任务已执行次数，对于次数异常的，作相应的处理。</li>
<li>在消费者类的 <code>fire()</code> 方法中，根据业务数据来判断该任务是否已经执行过，以避免该任务被重复执行。</li>
<li>编写失败回调事件，将事件中失败的任务及时通知给开发人员。</li>
</ul>
</li>
<li>
<p><strong>3.7.2</strong> 使用了 <code>queue:work --daemon</code> ，但更新代码后没有使用 <code>queue:restart</code> 重启 work 进程, 使得 work  进程中的代码与最新的代码不同，出现各种问题。</p>
</li>
<li>
<p><strong>3.7.3</strong> 使用了 <code>queue:work --daemon</code> ，但是消费者类的 fire() 方法中存在死循环，或 <code>sleep(n)</code> 等逻辑，导致消息队列被堵塞；或者使用了 <code>exit()</code> , <code>die()</code> 这样的逻辑，导致work进程直接终止 。</p>
</li>
<li>
<p><strong>3.7.4</strong> 配置的 expire 为<code>null</code> ，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。</p>
</li>
<li>
<p><strong>3.7.5</strong> 配置的 expire <code>不为null</code> ，但配置的 expire 时间太短，以至于  expire 时间 &lt; 消费者的 <code>fire()</code> 方法所需时间 +  删除该任务所需的时间 ，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。</p>
</li>
<li>
<p><strong>3.7.6</strong> queue:work 属于 cli 模式, 其入口文件是根目录下的 think 文件, 网页访问属于 sapi 模式, 其入口是 public 目录下的 index.php 文件.  如果需要在入口文件中定义自定义常量, 记得去修改对应的入口文件.   具体可参考 chichoyi 的说明 https://github.com/coolseven/notes/issues/7</p>
</li>
</ul>
<h3 id="四-拓展">四 拓展</h3>
<h4 id="41-队列的稳定性和拓展性">4.1 队列的稳定性和拓展性</h4>
<ul>
<li>稳定性：不管是 listen 模式还是 work 模式，都建议使用 supervisor 或者 自定义的cron 脚本，去定时检查 work 进程是否正常</li>
<li>拓展性： 当某个队列的消费者不足时，再给这个队列添加 work进程即可。</li>
</ul>
<h4 id="42-消息队列的可视化管理工具">4.2 消息队列的可视化管理工具</h4>
<ul>
<li>队列管理，队列的列表，队列的 work 进程数量控制，队列的任务数量变化趋势  //TBD</li>
<li>任务管理，任务的列表，添加/<strong>撤回</strong>/查询任务，修改任务的 执行者/执行时间/优先级/数据 等  //TBD</li>
</ul>
<h4 id="42-编写自定义的-thinkphp-queue-驱动">4.2 编写自定义的 thinkphp-queue 驱动</h4>
<p>//TBD</p>
<h4 id="43-编写消息队列的单元测试">4.3 编写消息队列的单元测试</h4>
<p>//TBD</p>
<h4 id="44-与其他php消息队列库的对比">4.4 与其他PHP消息队列库的对比</h4>
<p>TP5的消息队列与Laravel的消息队列比较相似，下面是与laravel 中的消息队列的一些对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>thinkphp-queue (v1.1.2)</th>
<th>laravel-queue (v5.3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>内置的驱动</td>
<td>Database，Redis，Sync，TopThink</td>
<td>Database，Redis, Sync(在laravel中称为 null)。</td>
</tr>
<tr>
<td>Redis驱动要求</td>
<td>安装redis的C扩展</td>
<td>安装 predis 包 + LUA脚本</td>
</tr>
<tr>
<td>推送任务</td>
<td>允许推送 消费者类名，消费者对象</td>
<td>允许推送消费者类名，消费者对象，闭包</td>
</tr>
<tr>
<td>失败任务处理</td>
<td>触发失败回调事件 (有Bug)</td>
<td>触发失败回调事件 + 移动任务到 failed_jobs表?</td>
</tr>
<tr>
<td>消息订阅</td>
<td>subscribe 命令+ Topthink驱动(注：未实现/未提供)</td>
<td>subscribe 命令 + 安装IronMQ 驱动</td>
</tr>
<tr>
<td>删除任务</td>
<td>消费者类中手动删除</td>
<td>任务完成后自动删除</td>
</tr>
<tr>
<td>推送到多个队列</td>
<td>需自己实现</td>
<td>原生支持</td>
</tr>
<tr>
<td>延迟执行</td>
<td>支持 (有Bug)</td>
<td>支持</td>
</tr>
<tr>
<td>消息重发</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>检查已执行次数</td>
<td>原生支持</td>
<td>需在消费者类中显式 use 相关的 trait</td>
</tr>
<tr>
<td>执行方式</td>
<td>work 模式 + listen 模式</td>
<td>work 模式 + listen 模式</td>
</tr>
<tr>
<td>进程命令</td>
<td>开启，停止，重启</td>
<td>开启，停止，重启</td>
</tr>
<tr>
<td>任务命令</td>
<td>无</td>
<td>展示失败任务列表，重试某个失败任务，删除某个失败任务</td>
</tr>
<tr>
<td>支持的事件</td>
<td>失败回调事件</td>
<td>失败回调事件，支持消费前事件，消费后事件</td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%B8%80-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">一 代码示例</a>
<ul>
<li><a href="#11-%E5%AE%89%E8%A3%85-thinkphp-queue">1.1 安装 thinkphp-queue</a></li>
<li><a href="#12-%E6%90%AD%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%8E%AF%E5%A2%83">1.2 搭建消息队列的存储环境</a></li>
<li><a href="#13-%E9%85%8D%E7%BD%AE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%A9%B1%E5%8A%A8">1.3 配置消息队列的驱动</a></li>
<li><a href="#14-%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8E%A8%E9%80%81">1.4 消息的创建与推送</a></li>
<li><a href="#15-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E4%B8%8E%E5%88%A0%E9%99%A4">1.5 消息的消费与删除</a></li>
<li><a href="#16-%E5%8F%91%E5%B8%83%E4%BB%BB%E5%8A%A1">1.6 发布任务</a></li>
<li><a href="#17-%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1">1.7 处理任务</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">二 详细介绍</a>
<ul>
<li><a href="#21-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">2.1 命令模式</a></li>
<li><a href="#22-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">2.2 命令行参数</a></li>
<li><a href="#23-work-%E6%A8%A1%E5%BC%8F%E5%92%8C-listen-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">2.3 work 模式和 listen 模式的区别</a></li>
<li><a href="#24-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%80%E5%A7%8B%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%90%AF">2.4 消息队列的开始，停止与重启</a></li>
<li><a href="#25-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86">2.5 多模块，多任务的处理</a></li>
<li><a href="#26-%E6%B6%88%E6%81%AF%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C">2.6 消息的延迟执行与定时执行</a></li>
<li><a href="#27-%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%8F%91">2.7 消息的重发</a></li>
<li><a href="#28-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%91%8A%E8%AD%A6">2.8 任务的失败回调及告警</a></li>
<li><a href="#29-%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BB%BB%E5%8A%A1">2.9 处理过期的任务</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">三 深入理解</a>
<ul>
<li><a href="#31-thinkphp-queue-%E4%B8%AD%E6%B6%88%E6%81%AF%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BF%9D%E5%AD%98%E6%96%B9%E5%BC%8F">3.1 thinkphp-queue 中消息与队列的保存方式</a></li>
<li><a href="#32-thinkphp-queue-%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE">3.2 thinkphp-queue 的目录结构和类关系图</a></li>
<li><a href="#33-deamon%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">3.3 Deamon模式的执行流程</a></li>
<li><a href="#34-database%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">3.4 Database模式下消息处理的详细流程</a></li>
<li><a href="#35-redis-%E9%A9%B1%E5%8A%A8%E4%B8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%8F%91%E7%BB%86%E8%8A%82">3.5 redis 驱动下的任务重发细节</a></li>
<li><a href="#36-thinkphp-queue%E7%9A%84%E6%80%A7%E8%83%BD">3.6 thinkphp-queue的性能</a></li>
<li><a href="#37-thinkphp-queue-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.7 thinkphp-queue 的注意事项</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%8B%93%E5%B1%95">四 拓展</a>
<ul>
<li><a href="#41-%E9%98%9F%E5%88%97%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%8B%93%E5%B1%95%E6%80%A7">4.1 队列的稳定性和拓展性</a></li>
<li><a href="#42-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">4.2 消息队列的可视化管理工具</a></li>
<li><a href="#42-%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-thinkphp-queue-%E9%A9%B1%E5%8A%A8">4.2 编写自定义的 thinkphp-queue 驱动</a></li>
<li><a href="#43-%E7%BC%96%E5%86%99%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">4.3 编写消息队列的单元测试</a></li>
<li><a href="#44-%E4%B8%8E%E5%85%B6%E4%BB%96php%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94">4.4 与其他PHP消息队列库的对比</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yulinzhihou.github.io/post/gs-ming-ling-ji-pei-zhi-xiang-jie/">
              <h3 class="post-title">
                GS 命令及配置详解
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'ca1d6fb437a399da4390',
    clientSecret: 'e18e044fef2b96cd190004ede9be6618f319295b',
    repo: 'yulinzhihou.github.io',
    owner: 'yulinzhihou',
    admin: ['yulinzhihou'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9155979519748628"
     crossorigin="anonymous"></script>
  <a class="rss" href="https://yulinzhihou.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
